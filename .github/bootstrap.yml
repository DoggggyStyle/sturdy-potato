name: Bootstrap → Generate Godot Project + Build + Pages

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: write   # 允许把生成的文件回写到仓库
  pages: write
  id-token: write

jobs:
  bootstrap:
    runs-on: ubuntu-latest
    env:
      VER: "4.4.1"
      GODOT: godot
      PROJ: project

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          persist-credentials: true

      - name: Generate project skeleton & minimal gameplay
        run: |
          set -euo pipefail
          mkdir -p $PROJ/{ci,scenes,scripts/{camera,controllers,units}} .github/workflows Build

          # ---- project.godot ----
          cat > $PROJ/project.godot <<'INI'
[application]
config/name="Ultimate Hacker"
run/main_scene="res://scenes/Main.tscn"
INI

          # ---- Minimal playable scene ----
          cat > $PROJ/scenes/Main.tscn <<'TSCN'
[gd_scene load_steps=7 format=3]
[node name="Main" type="Node3D"]
[node name="Ground" type="StaticBody3D" parent="."]
[node name="GroundMesh" type="MeshInstance3D" parent="Ground"]
mesh = SubResource("PlaneMesh_1")
[node name="GroundCol" type="CollisionShape3D" parent="Ground"]
shape = SubResource("BoxShape_1")
[node name="RTSCamera" type="Node3D" parent="."]
script = ExtResource("res://scripts/camera/RTSCamera_Pro.gd")
[node name="Camera3D" type="Camera3D" parent="RTSCamera"]
[node name="Controller" type="Node" parent="."]
script = ExtResource("res://scripts/controllers/SelectionController.gd")
rts_camera_path = NodePath("../RTSCamera")
[node name="UnitA" type="CharacterBody3D" parent="."]
script = ExtResource("res://scripts/units/Unit.gd")
[node name="UnitB" type="CharacterBody3D" parent="."]
script = ExtResource("res://scripts/units/Unit.gd")
[sub_resource type="PlaneMesh" id="PlaneMesh_1"]
size = Vector2(100, 100)
[sub_resource type="BoxShape3D" id="BoxShape_1"]
size = Vector3(100, 0.2, 100)
TSCN

          # ---- RTS camera (Godot 4) ----
          cat > $PROJ/scripts/camera/RTSCamera_Pro.gd <<'GD'
extends Node3D
class_name RTSCamera
@export var camera_path: NodePath
@export var pan_speed: float = 18.0
@export var pan_speed_alt_factor: float = 0.6
@export var rotate_speed_deg: float = 120.0
@export var zoom_min: float = 6.0
@export var zoom_max: float = 80.0
@export var zoom_step: float = 3.0
@export var tilt_min_deg: float = 30.0
@export var tilt_max_deg: float = 60.0
@export var smooth: float = 10.0
@export var edge_pan := true
@export var edge_px := 14
@export var mmb_drag := true
@export var mmb_sensitivity: float = 1.0
@export var use_bounds := false
@export var bounds_min := Vector2(-200.0, -200.0)
@export var bounds_max := Vector2(200.0, 200.0)
@export var min_ground_clearance: float = 2.0
@export var ground_mask: int = 1
@export var ray_length: float = 5000.0
@export var double_click_ms := 280
@export var follow_smooth: float = 8.0
signal centered_on(target: Node)
signal follow_started(target: Node3D)
signal follow_stopped()
var cam: Camera3D
var _target_pos: Vector3
var _target_yaw: float = 0.0
var _target_dist: float = 20.0
var _dragging := false
var _last_rclick_ms: int = -99999
var _follow_target: Node3D
var _tilt_locked := false
var _tilt_lock_value_deg: float = 45.0
var follow_offset := Vector3.ZERO
func _ready() -> void:
	cam = get_node_or_null(camera_path) as Camera3D
	if cam == null and has_node("Camera3D"): cam = $Camera3D
	assert(cam != null, "RTSCamera: Camera3D not found.")
	_target_pos = global_position
	_target_yaw = rotation.y
	_target_dist = clampf(20.0, zoom_min, zoom_max)
	_apply_immediate()
func _unhandled_input(e: InputEvent) -> void:
	if e is InputEventMouseButton:
		if e.button_index == MOUSE_BUTTON_WHEEL_UP and e.pressed:
			_target_dist = maxf(zoom_min, _target_dist - zoom_step); if Input.is_key_pressed(KEY_SHIFT): _lock_current_tilt()
		elif e.button_index == MOUSE_BUTTON_WHEEL_DOWN and e.pressed:
			_target_dist = minf(zoom_max, _target_dist + zoom_step); if Input.is_key_pressed(KEY_SHIFT): _lock_current_tilt()
		elif e.button_index == MOUSE_BUTTON_MIDDLE:
			_dragging = e.pressed and mmb_drag
		elif e.button_index == MOUSE_BUTTON_RIGHT and e.pressed:
			var now := Time.get_ticks_msec()
			if now - _last_rclick_ms <= double_click_ms: _center_to_mouse_ground()
			_last_rclick_ms = now
	elif e is InputEventMouseMotion and _dragging:
		_pan_screen(-e.relative.x, -e.relative.y)
func _process(delta: float) -> void:
	_gather_keyboard_edge_input(delta); _handle_rotate(delta)
	_follow_update(delta); _clamp_to_bounds(); _keep_over_ground(); _apply_smooth(delta)
func _gather_keyboard_edge_input(delta: float) -> void:
	var v := Vector2.ZERO
	v.x += Input.get_action_strength("ui_right") - Input.get_action_strength("ui_left")
	v.y += Input.get_action_strength("ui_down") - Input.get_action_strength("ui_up")
	if edge_pan:
		var m := get_viewport().get_mouse_position()
		var sz := get_viewport().get_visible_rect().size
		if m.x <= edge_px: v.x -= 1.0
		if m.x >= sz.x - edge_px: v.x += 1.0
		if m.y <= edge_px: v.y -= 1.0
		if m.y >= sz.y - edge_px: v.y += 1.0
	if v == Vector2.ZERO: return
	_stop_follow(); v = v.normalized()
	var forward := -Basis.from_euler(Vector3(0.0, _target_yaw, 0.0)).z
	var right :=  Basis.from_euler(Vector3(0.0, _target_yaw, 0.0)).x
	var alt := 1.0 + (_target_dist / zoom_max) * pan_speed_alt_factor
	_target_pos += (right * v.x + forward * v.y) * pan_speed * alt * delta
func _handle_rotate(delta: float) -> void:
	var dir := 0.0
	if Input.is_key_pressed(KEY_Q): dir += 1.0
	if Input.is_key_pressed(KEY_E): dir -= 1.0
	if dir != 0.0: _stop_follow(); _target_yaw += deg_to_rad(dir * rotate_speed_deg * delta)
func _pan_screen(dx: float, dy: float) -> void:
	_stop_follow()
	var f := -Basis.from_euler(Vector3(0.0, _target_yaw, 0.0)).z
	var r :=  Basis.from_euler(Vector3(0.0, _target_yaw, 0.0)).x
	var s := 0.02 * (_target_dist / 20.0) * mmb_sensitivity
	_target_pos += r * dx * s + f * dy * s
func _center_to_mouse_ground() -> void:
	var hit := _raycast_mouse_to_ground()
	if hit.has("position"): _stop_follow(); _target_pos = hit.position; emit_signal("centered_on", self)
func start_follow(target: Node3D, offset := Vector3.ZERO) -> void:
	_follow_target = target; follow_offset = offset
	if _follow_target: emit_signal("follow_started", _follow_target)
func _stop_follow() -> void:
	if _follow_target: _follow_target = null; emit_signal("follow_stopped")
func _follow_update(delta: float) -> void:
	if _follow_target == null: return
	var dst := _follow_target.global_position + follow_offset
	_target_pos = _target_pos.lerp(dst, 1.0 - exp(-follow_smooth * delta))
func _apply_smooth(delta: float) -> void:
	var tilt_deg := _compute_tilt_deg()
	rotation.y = lerp_angle(rotation.y, _target_yaw, 1.0 - exp(-smooth * delta))
	global_position = global_position.lerp(_target_pos, 1.0 - exp(-smooth * delta))
	var off := _orbit_offset(_target_dist, deg_to_rad(tilt_deg))
	cam.global_transform = global_transform * Transform3D(Basis.IDENTITY, off)
	cam.look_at(global_position)
func _apply_immediate() -> void:
	var tilt_deg := _compute_tilt_deg()
	rotation.y = _target_yaw; global_position = _target_pos
	var off := _orbit_offset(_target_dist, deg_to_rad(tilt_deg))
	cam.global_transform = global_transform * Transform3D(Basis.IDENTITY, off)
	cam.look_at(global_position)
func _compute_tilt_deg() -> float:
	if _tilt_locked: return _tilt_lock_value_deg
	var t := clampf((_target_dist - zoom_min) / maxf(0.001, (zoom_max - zoom_min)), 0.0, 1.0)
	return lerp(tilt_min_deg, tilt_max_deg, t)
func _lock_current_tilt() -> void:
	_tilt_locked = true
	var t := clampf((_target_dist - zoom_min) / maxf(0.001, (zoom_max - zoom_min)), 0.0, 1.0)
	_tilt_lock_value_deg = lerp(tilt_min_deg, tilt_max_deg, t)
func _input(event: InputEvent) -> void:
	if event is InputEventKey and not event.pressed and event.keycode == KEY_SHIFT: _tilt_locked = false
func _clamp_to_bounds() -> void:
	if not use_bounds: return
	_target_pos.x = clampf(_target_pos.x, bounds_min.x, bounds_max.x)
	_target_pos.z = clampf(_target_pos.z, bounds_min.y, bounds_max.y)
func _keep_over_ground() -> void:
	var hit := _raycast_at_position(Vector3(_target_pos.x, 1000.0, _target_pos.z), Vector3.DOWN)
	if hit.has("position"):
		var g := hit.position
		if _target_pos.y < g.y + min_ground_clearance: _target_pos.y = g.y + min_ground_clearance
func _orbit_offset(dist: float, tilt_rad: float) -> Vector3:
	var back := -Basis.from_euler(Vector3(0.0, _target_yaw, 0.0)).z
	var up := Vector3.UP
	return (back.normalized() * cos(tilt_rad) + up * sin(tilt_rad)) * dist
func _raycast_mouse_to_ground() -> Dictionary:
	var vp := get_viewport(); if vp == null or cam == null: return {}
	var m := vp.get_mouse_position()
	var from := cam.project_ray_origin(m)
	var dir := cam.project_ray_normal(m)
	return _intersect_ray(from, from + dir * ray_length)
func _raycast_at_position(from: Vector3, dir: Vector3) -> Dictionary:
	return _intersect_ray(from, from + dir * ray_length)
func _intersect_ray(from: Vector3, to: Vector3) -> Dictionary:
	var q := PhysicsRayQueryParameters3D.create(from, to, ground_mask)
	return get_world_3d().direct_space_state.intersect_ray(q)
GD

          # ---- Unit（左键选中，右键地面移动）----
          cat > $PROJ/scripts/units/Unit.gd <<'GD'
extends CharacterBody3D
class_name Unit
@export var move_speed := 6.0
var goto_point: Vector3
var has_goal := false
func _ready() -> void:
	add_to_group("unit"); goto_point = global_position
func set_goal(p: Vector3) -> void:
	goto_point = p; has_goal = true
func _physics_process(delta: float) -> void:
	if has_goal:
		var dir := (goto_point - global_position); dir.y = 0.0
		if dir.length() < 0.2: has_goal = false; velocity = Vector3.ZERO; return
		dir = dir.normalized(); velocity.x = dir.x * move_speed; velocity.z = dir.z * move_speed; move_and_slide()
GD

          # ---- Selection / order controller ----
          cat > $PROJ/scripts/controllers/SelectionController.gd <<'GD'
extends Node
@export var rts_camera_path: NodePath
@export var ground_mask := 1
@export var unit_mask := 1
var cam: Camera3D
var rts: RTSCamera
var selected: Array[Node3D] = []
func _ready() -> void:
	_ensure_action("select_primary", MOUSE_BUTTON_LEFT)
	_ensure_action("order_move", MOUSE_BUTTON_RIGHT)
	_ensure_key_action("toggle_follow", KEY_F)
	_ensure_key_action("toggle_follow_alt", KEY_SPACE)
	var node := get_node(rts_camera_path)
	if node is RTSCamera:
		rts = node; cam = rts.get_node("Camera3D") as Camera3D
func _unhandled_input(e: InputEvent) -> void:
	if e is InputEventMouseButton and e.pressed:
		if e.button_index == MOUSE_BUTTON_LEFT: _select_under_mouse()
		elif e.button_index == MOUSE_BUTTON_RIGHT: _order_move_to_mouse()
	if e is InputEventKey and e.pressed and (e.keycode == KEY_F or e.keycode == KEY_SPACE):
		_toggle_follow()
func _select_under_mouse() -> void:
	var u := _ray_to_unit(); selected = [] if u == null else [u]
func _order_move_to_mouse() -> void:
	if selected.is_empty(): return
	var p := _ray_to_ground(); if p == null: return
	for u in selected:
		if u.has_method("set_goal"): u.set_goal(p)
func _toggle_follow() -> void:
	if rts == null: return
	if selected.is_empty(): rts.start_follow(null); return
	var u := selected[0]
	if rts._follow_target == u: rts._stop_follow() else: rts.start_follow(u, Vector3.ZERO)
func _ray_to_ground() -> Vector3:
	var m := get_viewport().get_mouse_position()
	var from := cam.project_ray_origin(m); var dir := cam.project_ray_normal(m)
	var q := PhysicsRayQueryParameters3D.create(from, from + dir * 5000.0, ground_mask)
	var hit := get_world_3d().direct_space_state.intersect_ray(q)
	return hit.position if hit.has("position") else null
func _ray_to_unit() -> Node3D:
	var m := get_viewport().get_mouse_position()
	var from := cam.project_ray_origin(m); var dir := cam.project_ray_normal(m)
	var q := PhysicsRayQueryParameters3D.create(from, from + dir * 5000.0, unit_mask)
	var hit := get_world_3d().direct_space_state.intersect_ray(q)
	return hit.collider if hit.has("collider") and hit.collider is Node3D and hit.collider.is_in_group("unit") else null
func _ensure_action(name: String, mouse_button: int) -> void:
	if not InputMap.has_action(name): InputMap.add_action(name)
	var ev := InputEventMouseButton.new(); ev.button_index = mouse_button; InputMap.action_add_event(name, ev)
func _ensure_key_action(name: String, keycode: int) -> void:
	if not InputMap.has_action(name): InputMap.add_action(name)
	var ev := InputEventKey.new(); ev.keycode = keycode; InputMap.action_add_event(name, ev)
GD

          # ---- export presets（与后续导出命令一致）----
          cat > $PROJ/export_presets.cfg <<'INI'
[preset.0]
name="Windows Desktop"
platform="Windows Desktop"
runnable=true
export_filter="all_resources"
export_path="../Build/Windows/UltimateHacker.exe"
script_export_mode=1
[preset.0.options]
binary_format/architecture="x86_64"
texture_format/s3tc=true
texture_format/etc2=true
texture_format/bptc=true
[preset.1]
name="Linux/X11"
platform="Linux/X11"
runnable=true
export_filter="all_resources"
export_path="../Build/Linux/UltimateHacker.x86_64"
script_export_mode=1
[preset.1.options]
binary_format/architecture="x86_64"
texture_format/s3tc=true
texture_format/etc2=true
texture_format/bptc=true
[preset.2]
name="Web"
platform="Web"
runnable=true
export_filter="all_resources"
export_path="../Build/Web/index.html"
script_export_mode=1
[preset.2.options]
texture_format/s3tc=true
texture_format/etc2=true
texture_format/bptc=true
html/export_icon=true
INI

          # ---- strict preload check（CI 与本地同步报错）----
          cat > $PROJ/ci/check_all.gd <<'GD'
extends SceneTree
func _init() -> void:
	for p in _walk("res://"):
		if p.ends_with(".gd"):
			print("CHECK:", p)
			var s = load(p) # 有错就 fail
	quit(0)
func _walk(root: String) -> PackedStringArray:
	var out := PackedStringArray()
	var d := DirAccess.open(root)
	if d == null: return out
	d.list_dir_begin()
	while true:
		var n := d.get_next()
		if n == "": break
		if n.begins_with("."): continue
		var path := root + n
		if d.current_is_dir(): out.append_array(_walk(path + "/"))
		else: out.append(path)
	d.list_dir_end()
	return out
GD

      - name: Auto-commit generated files
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore(bootstrap): generate minimal Godot project & CI"
          commit_user_name: "github-actions[bot]"
          commit_user_email: "41898282+github-actions[bot]@users.noreply.github.com"
          push_options: "--force"

      - name: Install Godot ${{ env.VER }} headless
        run: |
          set -e
          wget -q https://downloads.tuxfamily.org/godotengine/${VER}/Godot_v${VER}-stable_linux.x86_64.zip -O godot.zip
          unzip -q godot.zip -d godota && rm godot.zip
          sudo mv godota/Godot_v${VER}-stable_linux.x86_64 /usr/local/bin/${GODOT}
          sudo chmod +x /usr/local/bin/${GODOT}
          ${GODOT} --version

      - name: Install export templates
        run: |
          set -e
          mkdir -p ~/.local/share/godot/export_templates/${VER}.stable/
          wget -q https://downloads.tuxfamily.org/godotengine/${VER}/Godot_v${VER}-stable_export_templates.tpz -O t.tpz
          unzip -q t.tpz -d ~/.local/share/godot/export_templates/${VER}.stable/ && rm t.tpz

      - name: Syntax check (preload all scripts)
        run: ${GODOT} --headless --path ${PROJ} -s res://ci/check_all.gd

      - name: Export Linux
        run: |
          mkdir -p Build/Linux
          ${GODOT} --headless --path ${PROJ} --export-release "Linux/X11"   ./Build/Linux/UltimateHacker.x86_64
          chmod +x Build/Linux/UltimateHacker.x86_64

      - name: Export Windows
        run: |
          mkdir -p Build/Windows
          ${GODOT} --headless --path ${PROJ} --export-release "Windows Desktop" ./Build/Windows/UltimateHacker.exe

      - name: Export Web
        run: |
          mkdir -p Build/Web
          ${GODOT} --headless --path ${PROJ} --export-release "Web" ./Build/Web/index.html

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: builds
          path: |
            Build/Linux/**
            Build/Windows/**
            Build/Web/**

      - name: Configure Pages
        uses: actions/configure-pages@v5
      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: Build/Web
      - name: Deploy to Pages
        uses: actions/deploy-pages@v4
